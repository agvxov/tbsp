const char * const TBSP_header = "\
/* This file was auto generated by \
"
#include "version.inc"
"\
.\n\
 * DO NOT EDIT IT DIRECTLY IT WILL MOST LIKELY BE OVER WRITTEN!\n\
 */\n\
#include <stdio.h>\n\
#include <string.h>\n\
\n\
#include <tree_sitter/api.h>\n\
#ifdef __cplusplus\n\
extern \"C\" {\n\
#endif\n\
extern const TSLanguage * tree_sitter_%s(void);\n\
#ifdef __cplusplus\n\
}\n\
#endif\n\
const TSLanguage * (*tblanguage_function)(void) = tree_sitter_%s;\n\
\n\
typedef struct {\n\
	const char * const string;\n\
	const int case_number;\n\
} tbcase_t;\n\
\n\
// XXX better search algo\n\
int tbdetermine_case(const tbcase_t * const ordered_array, const char * const string) {\n\
    const tbcase_t * c = ordered_array;\n\
    for (; c->string != NULL; c++) {\n\
        if (!strcmp(c->string, string)) { break; }\n\
    }\n\
\n\
    return c->case_number;\n\
}\n\
\n\
char * tbtext(const char * const code, TSNode node) {\n\
    int tblen = ts_node_end_byte(node) - ts_node_start_byte(node);\n\
    char * r = (char *)malloc(sizeof(char) * (tblen + 1));\n\
\n\
    memcpy(r, code + ts_node_start_byte(node), tblen);\n\
    r[tblen] = '\\0';\n\
\n\
    return r;\n\
}\n\
\n\
#define tbget_text tbtext(tbcode, tbnode)\n\
#define tbget_node_text(n) tbtext(tbcode, n)\n\
#define tbis_enter (tbcurrent_cases == tbenter_cases)\n\
";

const char * const TBSP_case = "\
    (tbcase_t) { .string = \"%s\", .case_number = %d },\n\
";

const char * const TBSP_traverse_top = "\
int tbtraverse(const char * const tbcode) {\n\
    // init\n\
    TSParser * tbparser;\n\
    TSTree * tbtree;\n\
    TSTreeCursor tbcursor;\n\
    TSNode tbnode;\n\
\n\
    int tbcase;\n\
\n\
    tbparser = ts_parser_new();\n\
\n\
    ts_parser_set_language(tbparser, tblanguage_function());\n\
\n\
    tbtree = ts_parser_parse_string(tbparser, NULL, tbcode, strlen(tbcode));\n\
    tbcursor = ts_tree_cursor_new(ts_tree_root_node(tbtree));\n\
    tbnode = ts_tree_root_node(tbtree);\n\
\n\
    const tbcase_t * tbcurrent_cases = tbenter_cases;\n\
\n\
    // meat\n\
    while (true) {\n\
        tbnode = ts_tree_cursor_current_node(&tbcursor);\n\
      #if defined(TBDEBUG) && TBDEBUG == 1\n\
        puts(ts_node_string(tbnode));\n\
      #endif\n\
\n\
        tbcase = tbdetermine_case(tbcurrent_cases, ts_node_type(tbnode));\n\
\n\
        switch (tbcase) {\n\
            // XXX INJECTION\n\
";

const char * const TBSP_traverse_bottom = "\
                    default: { ; } break;\n\
        }\n\
\n\
        if (ts_node_child_count(tbnode)\n\
        &&  tbcurrent_cases == tbenter_cases) {\n\
            ts_tree_cursor_goto_first_child(&tbcursor);\n\
            continue;\n\
        }\n\
\n\
      tblogic:\n\
        if (!ts_node_is_null(ts_node_next_sibling(tbnode))) {\n\
            if (tbcurrent_cases == tbenter_cases) {\n\
                tbcurrent_cases = tbleave_cases;\n\
                continue;\n\
            } else {\n\
                ts_tree_cursor_goto_next_sibling(&tbcursor);\n\
                tbcurrent_cases = tbenter_cases;\n\
                continue;\n\
            }\n\
        }\n\
\n\
        if (tbcurrent_cases == tbenter_cases) {\n\
            tbcurrent_cases = tbleave_cases;\n\
            continue;\n\
        }\n\
\n\
        if (ts_tree_cursor_goto_parent(&tbcursor)) {\n\
            tbcurrent_cases = tbenter_cases;\n\
            goto tblogic;\n\
        }\n\
\n\
        break;\n\
    }\n\
\n\
    // deinit\n\
    ts_tree_delete(tbtree);\n\
    ts_parser_delete(tbparser);\n\
    ts_tree_cursor_delete(&tbcursor);\n\
\n\
    return 0;\n\
}\n\
";
